# FastAPI 애플리케이션 진입점 
from fastapi import FastAPI, HTTPException, Depends
from contextlib import asynccontextmanager
import uvicorn
import logging
import time
import asyncio # Added for background task
from datetime import datetime

from src.config import settings
from src.brokers.kis import KisBroker, KisBrokerError
from src.agents.strategy import TradingStrategy
from src.agents.risk_guard import RiskGuard
from src.db.models import SessionLocal, engine, create_tables # Assuming DB setup
from qdrant_client import QdrantClient

# --- 로깅 설정 --- 
logging.basicConfig(level=logging.INFO, 
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
# Lower logging level for specific modules if needed
# logging.getLogger('src.brokers.kis').setLevel(logging.DEBUG) 
# logging.getLogger('src.agents.strategy').setLevel(logging.DEBUG)
# logging.getLogger('src.agents.risk_guard').setLevel(logging.DEBUG)

logger = logging.getLogger(__name__)

# --- 전역 변수 및 상태 --- 
# 에이전트 및 클라이언트 인스턴스를 저장할 딕셔너리
app_state = {}
background_tasks = set()

# --- Background Trading Loop Logic ---
async def background_trading_loop():
    """Runs the trading cycle periodically in the background."""
    logger.info("Background trading loop starting...")
    try:
        # Get components initialized during lifespan
        broker = app_state.get('broker')
        strategy = app_state.get('strategy')
        risk_guard = app_state.get('risk_guard')

        if not all([broker, strategy, risk_guard]):
            logger.error("Trading components not initialized correctly. Stopping background loop.")
            return

        while True:
            now = datetime.now()
            # Basic check: Run only on weekdays during typical market hours (e.g., 9 AM to 3:30 PM)
            is_market_hours = now.weekday() < 5 and 9 <= now.hour < 16 # Simplified check

            if is_market_hours:
                logger.info(f"Current time: {now}. Running trading cycle.")
                # --- Start of Trading Cycle Logic (moved from run_trading_cycle) ---
                logger.info("========== Starting Trading Cycle ==========")
                try:
                    all_orders_to_execute = []

                    # 1. Generate signals (Rebalance or Initial)
                    if strategy.check_rebalance_timing():
                        logger.info("Running rebalancing logic...")
                        signals = strategy.generate_rebalance_signals()
                    else:
                        logger.info("Checking for initial buy signals (if applicable)...")
                        # Consider adding logic to prevent daily initial buys if already invested
                        signals = strategy.generate_signals()

                    # 2. Validate generated signals
                    if signals:
                        validated_signals = risk_guard.validate_orders(signals)
                        logger.info(f"{len(validated_signals)} signals passed initial validation.")
                        all_orders_to_execute.extend(validated_signals)
                    else:
                        logger.info("No signals generated by the strategy.")

                    # 3. Check for stop-loss conditions
                    try:
                        logger.info("Checking for stop-loss conditions...")
                        current_positions = await asyncio.to_thread(broker.get_positions) # Run sync I/O in thread
                        stop_loss_signals = await asyncio.to_thread(
                            risk_guard.check_stop_loss, current_positions
                        ) # Run potentially blocking CPU/IO in thread
                        if stop_loss_signals:
                            logger.info(f"{len(stop_loss_signals)} stop-loss signals generated.")
                            all_orders_to_execute.extend(stop_loss_signals)
                    except KisBrokerError as e:
                        logger.error(f"Failed to get positions for stop-loss check: {e}")
                    except Exception as e:
                        logger.error(f"Unexpected error during stop-loss check: {e}", exc_info=True)

                    # 4. Execute final orders
                    if not all_orders_to_execute:
                        logger.info("No orders to execute in this cycle.")
                    else:
                        logger.info(f"Attempting to execute {len(all_orders_to_execute)} final orders...")
                        executed_count = 0
                        failed_count = 0
                        for order in all_orders_to_execute:
                            try:
                                buy_sell_code = "02" if order['action'] == 'buy' else "01"
                                # Default to market order unless price is specified > 0
                                order_type = "00" if order.get('price', 0) > 0 else "01"
                                price_to_send = order.get('price', 0) if order_type == "00" else 0

                                if order['quantity'] <= 0:
                                    logger.warning(f"Skipping order with invalid quantity: {order}")
                                    continue

                                logger.info(f"Executing order: {order['action']} {order['quantity']} {order['symbol']} @ {'Market' if order_type == '01' else price_to_send}")

                                # Execute order using asyncio.to_thread for blocking call
                                order_result = await asyncio.to_thread(
                                    broker.order_cash,
                                    symbol=order['symbol'],
                                    quantity=order['quantity'],
                                    price=price_to_send,
                                    order_type=order_type,
                                    buy_sell_code=buy_sell_code
                                )
                                logger.info(f"Order execution result for {order['symbol']}: {order_result}")
                                executed_count += 1
                                await asyncio.sleep(settings.ORDER_INTERVAL_SECONDS)
                            except KisBrokerError as e:
                                logger.error(f"Failed to execute order {order}: {e}")
                                await asyncio.to_thread(risk_guard.handle_api_error, e, f"executing order for {order['symbol']}")
                                failed_count += 1
                                await asyncio.sleep(settings.API_ERROR_BACKOFF_SECONDS)
                            except Exception as e:
                                logger.error(f"Unexpected error executing order {order}: {e}", exc_info=True)
                                failed_count += 1
                                await asyncio.sleep(settings.API_ERROR_BACKOFF_SECONDS)
                        logger.info(f"Order execution finished. Executed: {executed_count}, Failed: {failed_count}")

                except KisBrokerError as e:
                    logger.error(f"A KIS API error occurred during the trading cycle: {e}")
                    await asyncio.to_thread(risk_guard.handle_api_error, e, "main trading cycle")
                except Exception as e:
                    logger.error(f"An unexpected error occurred during the trading cycle: {e}", exc_info=True)
                logger.info("========== Trading Cycle Finished ==========")
                # --- End of Trading Cycle Logic ---

                # Wait before the next cycle
                wait_seconds = settings.CYCLE_INTERVAL_MINUTES * 60
                logger.info(f"Cycle finished. Waiting for {settings.CYCLE_INTERVAL_MINUTES} minutes...")
            else:
                logger.debug(f"Current time: {now}. Outside trading hours/days. Sleeping...")
                # Check more frequently when outside market hours
                wait_seconds = 60 * 10 # Sleep for 10 minutes

            await asyncio.sleep(wait_seconds)

    except asyncio.CancelledError:
        logger.info("Background trading loop cancelled.")
    except Exception as e:
        logger.error(f"Fatal error in background trading loop: {e}", exc_info=True)
    finally:
        logger.info("Background trading loop finished.")

# --- FastAPI Lifespan 관리 --- 
@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Application startup...")
    try:
        # --- Initialize Components ---
        if not all([settings.APP_KEY, settings.APP_SECRET, settings.CANO, settings.ACNT_PRDT]):
            logger.error("Missing required KIS API credentials or account info in settings.")
            raise RuntimeError("Missing KIS API credentials")

        is_virtual = settings.KIS_VIRTUAL_ACCOUNT
        base_url = settings.KIS_VIRTUAL_URL if is_virtual else settings.BASE_URL
        logger.info(f"Running in {'VIRTUAL' if is_virtual else 'REAL'} mode.")

        broker = KisBroker(
            app_key=settings.APP_KEY,
            app_secret=settings.APP_SECRET,
            base_url=base_url,
            cano=settings.CANO,
            acnt_prdt_cd=settings.ACNT_PRDT,
            virtual_account=is_virtual
        )
        app_state['broker'] = broker
        logger.info("Broker initialized.")

        strategy = TradingStrategy(
            broker=broker,
            investment_amount=settings.INVESTMENT_AMOUNT,
            target_symbols=settings.TARGET_SYMBOLS
        )
        app_state['strategy'] = strategy
        logger.info("Strategy initialized.")

        risk_guard = RiskGuard(broker=broker)
        app_state['risk_guard'] = risk_guard
        logger.info("RiskGuard initialized.")

        # --- Initialize DB (if needed) ---
        # db = SessionLocal()
        # app_state['db_session'] = db
        # logger.info("DB session initialized.")

        # --- Initialize Qdrant (if needed) ---
        # qdrant_client = QdrantClient()
        # app_state['qdrant_client'] = qdrant_client
        # logger.info("Qdrant client initialized.")

        # --- Initialize Orchestrator (if needed) ---
        # orchestrator = Orchestrator(broker, db, qdrant_client)
        # app_state['orchestrator'] = orchestrator
        # logger.info("Orchestrator initialized.")

        # --- Start Background Task ---
        task = asyncio.create_task(background_trading_loop())
        background_tasks.add(task)
        # Ensure task finishes on shutdown
        task.add_done_callback(background_tasks.discard)

        yield # Application is running

    except Exception as e:
        logger.error(f"Error during application startup: {e}", exc_info=True)
        # Ensure cleanup happens even if startup fails partially
    finally:
        # --- Shutdown Logic --- 
        logger.info("Application shutdown...")
        # Gracefully cancel background tasks
        for task in list(background_tasks): # Iterate over a copy
            if not task.done():
                task.cancel()
        if background_tasks:
             logger.info(f"Waiting for {len(background_tasks)} background tasks to cancel...")
             # Give tasks a chance to clean up
             await asyncio.gather(*background_tasks, return_exceptions=True) 
             logger.info("Background tasks cancelled.")

        if 'broker' in app_state and app_state['broker']:
            # Run close in a thread as it might block
            await asyncio.to_thread(app_state['broker'].close) 
            logger.info("Broker session closed.")
        # Add cleanup for DB, Qdrant etc. if they were initialized
        # if 'db_session' in app_state and app_state['db_session']:
        #     app_state['db_session'].close()
        logger.info("Application shutdown complete.")

# --- FastAPI 앱 생성 --- 
app = FastAPI(
    title="KIS ETF Autotrade API",
    description="AI-powered ETF autotrading system using KIS OpenAPI.",
    version="1.1.0",
    lifespan=lifespan # Lifespan 이벤트 핸들러 등록
)

# --- 의존성 주입 함수 --- 
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def get_broker():
    broker = app_state.get('broker')
    if not broker:
         raise HTTPException(status_code=503, detail="Broker is not available")
    return broker

# --- API 라우터 --- 
@app.get("/")
async def read_root():
    return {"message": "Welcome to KIS ETF Autotrade API"}

@app.get("/health")
async def health_check(broker: KisBroker = Depends(get_broker)):
    broker_ok = False
    try:
        # Use asyncio.to_thread for potentially blocking check
        is_valid = await asyncio.to_thread(broker._is_token_valid) 
        if is_valid:
             broker_ok = True
        else:
             # Simple assumption: token can be re-requested
             broker_ok = True 
             logger.info("Health check: Broker token needs refresh (assumed ok).")
    except Exception as e:
        logger.warning(f"Health check: Broker connection failed - {e}")
        broker_ok = False

    # Add DB/Qdrant checks here if needed
    db_ok = True
    qdrant_ok = True

    status = "ok" if broker_ok and db_ok and qdrant_ok else "error"
    return {"status": status, "broker": broker_ok, "database": db_ok, "qdrant": qdrant_ok}

# Placeholder for manual trigger (might interact with background task state if needed)
@app.post("/trigger/cycle")
async def trigger_cycle_now():
    # NOTE: This doesn't directly run the cycle, as it's loop-based.
    # It could potentially set a flag that the loop checks to run immediately.
    logger.warning("Manual cycle trigger endpoint called - Functionality depends on loop implementation (currently time-based).")
    return {"message": "Trigger acknowledged. Background loop continues based on its schedule."}

# --- Main Execution Block ---
if __name__ == "__main__":
    logger.info("Initializing KIS AutoTrade System...")

    # --- Load Settings ---
    # Ensure necessary settings are available
    if not all([settings.APP_KEY, settings.APP_SECRET, settings.CANO, settings.ACNT_PRDT]):
        logger.error("Missing required KIS API credentials or account info in settings.")
        exit(1)
        
    is_virtual = settings.KIS_VIRTUAL_ACCOUNT
    base_url = settings.KIS_VIRTUAL_URL if is_virtual else settings.BASE_URL
    logger.info(f"Running in {'VIRTUAL' if is_virtual else 'REAL'} mode.")

    # --- Initialize Components ---
    try:
        broker = KisBroker(
            app_key=settings.APP_KEY,
            app_secret=settings.APP_SECRET,
            base_url=base_url,
            cano=settings.CANO,
            acnt_prdt_cd=settings.ACNT_PRDT,
            virtual_account=is_virtual
        )
        
        strategy = TradingStrategy(
            broker=broker,
            investment_amount=settings.INVESTMENT_AMOUNT,
            target_symbols=settings.TARGET_SYMBOLS 
            # TODO: Add other strategy parameters from settings if needed
        )
        
        risk_guard = RiskGuard(
            broker=broker
            # TODO: Add other risk parameters from settings if needed
        )
        
        logger.info("Broker, Strategy, and RiskGuard initialized successfully.")
        
    except Exception as e:
        logger.error(f"Failed to initialize components: {e}", exc_info=True)
        exit(1)

    # --- Main Loop ---
    logger.info("Starting main trading loop...")
    while True:
        # TODO: Implement more sophisticated scheduling (e.g., run only during market hours)
        now = datetime.now()
        # Basic check: Run only on weekdays during typical market hours (e.g., 9 AM to 3:30 PM)
        # This is a simplified check, market holidays are not considered
        if now.weekday() < 5 and 9 <= now.hour < 16: 
             logger.info(f"Current time: {now}. Running trading cycle.")
             run_trading_cycle(broker, strategy, risk_guard)
             # Wait before the next cycle
             logger.info(f"Cycle finished. Waiting for {settings.CYCLE_INTERVAL_MINUTES} minutes...")
             time.sleep(settings.CYCLE_INTERVAL_MINUTES * 60)
        else:
             logger.info(f"Current time: {now}. Outside trading hours/days. Sleeping...")
             # Check more frequently when outside market hours to start on time
             time.sleep(60 * 10) # Sleep for 10 minutes
             
        # TODO: Add graceful shutdown mechanism (e.g., KeyboardInterrupt)

    # Clean up (though the loop above runs indefinitely)
    # broker.close()
    # logger.info("System shut down.")

# --- Uvicorn 실행 --- 
if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=settings.PORT or 8000) 